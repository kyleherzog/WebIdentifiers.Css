// <autogenerated/>
#nullable enable
namespace WebIdentifiers.Css.Properties;

/// <summary>
/// Provides a CSS entry for the OverflowX property.
/// </summary>
public partial class OverflowXProperty : CssPropertyEntry
{
	/// <summary>
	/// Represents a overflow-x CSS property entry.
	/// </summary>
	/// <param name="value">An optional value with which to initialize the CSS property entry.</param>
	public OverflowXProperty(string? value = null)
		: base(CssPropertyNames.OverflowX, value)
	{
	}

	/// <summary>
	/// Sets the value of the property entry to <c>auto</c>. Like scroll when the box has scrollable overflow; like hidden otherwise. Thus, if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism will only be displayed if there is overflow.
	/// </summary>
	public OverflowXProperty SetToAuto()
	{
		Value = CssValues.Auto;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>clip</c>. This value indicates that the box’s content is clipped to its overflow clip edge and that no scrolling user interface should be provided by the UA to view the content outside the clipping region. In addition, unlike overflow: hidden which still allows programmatic scrolling, overflow: clip forbids scrolling entirely, through any mechanism, and therefore the box is not a scroll container. Unlike hidden, this value does not cause the element to establish a new formatting context.
	/// </summary>
	public OverflowXProperty SetToClip()
	{
		Value = CssValues.Clip;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>hidden</c>. This value indicates that the box’s content is clipped to its padding box and that the UA must not provide any scrolling user interface to view the content outside the clipping region, nor allow scrolling by direct intervention of the user, such as dragging on a touch screen or using the scrolling wheel on a mouse. However, the content must still be scrollable programmatically, for example using the mechanisms defined in [CSSOM-VIEW], and the box is therefore still a scroll container.
	/// </summary>
	public OverflowXProperty SetToHidden()
	{
		Value = CssValues.Hidden;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>overlay</c>. User agents must also support the overlay keyword as a legacy value alias of auto.
	/// </summary>
	public OverflowXProperty SetToOverlay()
	{
		Value = CssValues.Overlay;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>scroll</c>. This value indicates that the content is clipped to the padding box, but can be scrolled into view (and therefore the box is a scroll container). Furthermore, if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism should be displayed whether or not any of its content is clipped. This avoids any problem with scrollbars appearing and disappearing in a dynamic environment. When the target medium is print, overflowing content may be printed; it is not defined where it may be printed.
	/// </summary>
	public OverflowXProperty SetToScroll()
	{
		Value = CssValues.Scroll;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>visible</c>. There is no special handling of overflow, that is, the box’s content is rendered outside the box if positioned there. The box is not a scroll container.
	/// </summary>
	public OverflowXProperty SetToVisible()
	{
		Value = CssValues.Visible;
		return this;
	}


}