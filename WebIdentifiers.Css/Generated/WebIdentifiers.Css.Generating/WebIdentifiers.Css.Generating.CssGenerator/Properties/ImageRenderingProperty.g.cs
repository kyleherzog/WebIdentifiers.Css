// <autogenerated/>
#nullable enable
namespace WebIdentifiers.Css.Properties;

/// <summary>
/// Provides a CSS entry for the ImageRendering property.
/// </summary>
public partial class ImageRenderingProperty : CssPropertyEntry
{
	/// <summary>
	/// Represents a image-rendering CSS property entry.
	/// </summary>
	/// <param name="value">An optional value with which to initialize the CSS property entry.</param>
	public ImageRenderingProperty(string? value = null)
		: base(CssPropertyNames.ImageRendering, value)
	{
	}

	/// <summary>
	/// Sets the value of the property entry to <c>auto</c>. The scaling algorithm is UA-dependent.
	/// </summary>
	public ImageRenderingProperty SetToAuto()
	{
		Value = CssValues.Auto;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>crisp-edges</c>. The image is scaled in a way that preserves contrast and edges, and which avoids smoothing colors or introducing blur to the image in the process. This is intended for images such as line drawings. The image may be scaled using nearest neighbor or any other UA-chosen algorithm that does not blur edges or blend colors from the source image. It can, however, detect diagonal or curved lines and render them as such (rather than as jagged-looking “giant pixels”).
	/// </summary>
	public ImageRenderingProperty SetToCrispEdges()
	{
		Value = CssValues.CrispEdges;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>high-quality</c>. Identical to smooth, but with a preference for higher-quality scaling. If system resources are constrained, images with high-quality should be prioritized over those with any other value, when considering which images to degrade the quality of and to what degree.
	/// </summary>
	public ImageRenderingProperty SetToHighQuality()
	{
		Value = CssValues.HighQuality;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>pixelated</c>. The image is scaled in a way that preserves the pixelation of the original as much as possible, but allows minor smoothing as necessary to avoid distorting the image when the target size is not a clean multiple of the original. For each axis independently, first determine the integer multiple of its natural size that puts it closest to the target size and is greater than zero. Scale it to this integer-multiple-size using nearest neighbor, then scale it the rest of the way to the target size as for smooth.
	/// </summary>
	public ImageRenderingProperty SetToPixelated()
	{
		Value = CssValues.Pixelated;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>smooth</c>. The image should be scaled with an algorithm that maximizes the appearance of the image. In particular, scaling algorithms that &quot;smooth&quot; colors are acceptable, such as bilinear interpolation. This is intended for images such as photos.
	/// </summary>
	public ImageRenderingProperty SetToSmooth()
	{
		Value = CssValues.Smooth;
		return this;
	}


}