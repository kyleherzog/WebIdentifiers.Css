// <autogenerated/>
#nullable enable
namespace WebIdentifiers.Css.Properties;

/// <summary>
/// Provides a CSS entry for the Position property.
/// </summary>
public partial class PositionProperty : CssPropertyEntry
{
	/// <summary>
	/// Represents a position CSS property entry.
	/// </summary>
	/// <param name="value">An optional value with which to initialize the CSS property entry.</param>
	public PositionProperty(string? value = null)
		: base(CssPropertyNames.Position, value)
	{
	}

	/// <summary>
	/// Sets the value of the property entry to <c>absolute</c>. The box is taken out of flow such that it has no impact on the size or position of its siblings and ancestors, and does not participate in its parent’s formatting context. Instead, the box is positioned and sized solely in reference to its absolute positioning containing block, as modified by the box’s inset properties, see § 4 Absolute Positioning Layout Model. It can overlap in-flow content or other absolutely positioned elements, and is included in the scrollable overflow area of the box that generates is containing block. This positioning scheme is called absolute positioning.
	/// </summary>
	public PositionProperty SetToAbsolute()
	{
		Value = CssValues.Absolute;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>fixed</c>. Same as absolute, except the box is positioned and sized relative to a fixed positioning containing block (usually the viewport in continuous media, or the page area in paged media). The box’s position is fixed with respect to this reference rectangle: when attached to the viewport it does not move when the document is scrolled, and when attached to the page area is replicated on every page when the document is paginated. This positioning scheme is called fixed positioning and is considered a subset of absolute positioning. Authors may wish to specify fixed in a media-dependent way. For instance, an author may want a box to remain at the top of the viewport on the screen, but not at the top of each printed page. The two specifications may be separated by using an &apos;@media&apos; rule, as in: @media screen { h1#first { position: fixed } } @media print { h1#first { position: static } }
	/// </summary>
	public PositionProperty SetToFixed()
	{
		Value = CssValues.Fixed;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>relative</c>. The box is laid out as for static, then offset from the resulting position. This offsetting is a purely visual effect, and does not affect the size or position of any other box, except insofar as it increases the scrollable overflow area of its ancestors. This positioning scheme is called relative positioning.
	/// </summary>
	public PositionProperty SetToRelative()
	{
		Value = CssValues.Relative;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>static</c>. The box is not a positioned box, and is laid out according to the rules of its parent formatting context. The inset properties do not apply.
	/// </summary>
	public PositionProperty SetToStatic()
	{
		Value = CssValues.Static;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>sticky</c>. Identical to relative, except that its offsets are automatically adjusted in reference to the nearest ancestor scroll container’s scrollport (as modified by the inset properties) in whichever axes the inset properties are not both auto, to try to keep the box in view within its containing block as the user scrolls. This positioning scheme is called sticky positioning.
	/// </summary>
	public PositionProperty SetToSticky()
	{
		Value = CssValues.Sticky;
		return this;
	}


}