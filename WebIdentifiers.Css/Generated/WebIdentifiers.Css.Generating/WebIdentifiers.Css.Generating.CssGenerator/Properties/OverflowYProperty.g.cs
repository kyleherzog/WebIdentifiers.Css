// <autogenerated/>
namespace WebIdentifiers.Css.Properties;

/// <summary>
/// Provides a CSS entry for the OverflowY property.
/// </summary>
public partial class OverflowYProperty : CssPropertyEntry
{
	/// <summary>
	/// Represents a overflow-y CSS property entry.
	/// </summary>
	/// <param name="value">An optional value with which to initialize the CSS property entry.</param>
	public OverflowYProperty(string? value = null)
		: base(CssPropertyNames.OverflowY, value)
	{
	}

	/// <summary>
	/// Sets the value of the property entry to <c>auto</c>. Like scroll when the box has scrollable overflow; like hidden otherwise. Thus, if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism will only be displayed if there is overflow.
	/// </summary>
	public OverflowYProperty SetToAuto()
	{
		Value = CssValues.Auto;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>clip</c>. This value indicates that the box’s content is clipped to its overflow clip edge and that no scrolling user interface should be provided by the UA to view the content outside the clipping region. In addition, unlike overflow: hidden which still allows programmatic scrolling, overflow: clip forbids scrolling entirely, through any mechanism, and therefore the box is not a scroll container. Unlike hidden, this value does not cause the element to establish a new formatting context.
	/// </summary>
	public OverflowYProperty SetToClip()
	{
		Value = CssValues.Clip;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>hidden</c>. This value indicates that the box’s content is clipped to its padding box and that the UA must not provide any scrolling user interface to view the content outside the clipping region, nor allow scrolling by direct intervention of the user, such as dragging on a touch screen or using the scrolling wheel on a mouse. However, the content must still be scrollable programmatically, for example using the mechanisms defined in [CSSOM-VIEW], and the box is therefore still a scroll container.
	/// </summary>
	public OverflowYProperty SetToHidden()
	{
		Value = CssValues.Hidden;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>overlay</c>. User agents must also support the overlay keyword as a legacy value alias of auto.
	/// </summary>
	public OverflowYProperty SetToOverlay()
	{
		Value = CssValues.Overlay;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>scroll</c>. This value indicates that the content is clipped to the padding box, but can be scrolled into view (and therefore the box is a scroll container). Furthermore, if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism should be displayed whether or not any of its content is clipped. This avoids any problem with scrollbars appearing and disappearing in a dynamic environment. When the target medium is print, overflowing content may be printed; it is not defined where it may be printed.
	/// </summary>
	public OverflowYProperty SetToScroll()
	{
		Value = CssValues.Scroll;
		return this;
	}


	/// <summary>
	/// Sets the value of the property entry to <c>visible</c>. There is no special handling of overflow, that is, the box’s content is rendered outside the box if positioned there. The box is not a scroll container.
	/// </summary>
	public OverflowYProperty SetToVisible()
	{
		Value = CssValues.Visible;
		return this;
	}


}