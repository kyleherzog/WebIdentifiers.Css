using System;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using CodeCasing;
using Microsoft.CodeAnalysis;
using Newtonsoft.Json;
using WebIdentifiers.Css.Generating.Models;

namespace WebIdentifiers.Css.Generating
{
    [Generator]
    public class CssGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            LogInfo(context, "Starting CSS source code generation...");
            var references = LoadResources();

            WritePropertiesNamesClass(context, references);
            WriteEntriesClass(context, references);

            var valuesWriter = new ClassWriter();
            valuesWriter.AddUsings("WebIdentifiers.Css.Values");

            valuesWriter.AddLine("namespace WebIdentifiers.Css;");
            valuesWriter.AddLine();

            valuesWriter.AddXmlDocSummary("Provides predefined CSS values.");
            valuesWriter.OpenClass("CssValues", isStatic: true);

            var valuedProperties = references.Where(x => x.Properties is not null).SelectMany(x => x.Properties)
                .Where(x => x.Values is not null);
            var valueNames = valuedProperties
                .SelectMany(x => x.Values)
                .Select(x => x.Name)
                .Where(x => !x.Contains('<') && !x.Contains('|') && !x.StartsWith("[") && !x.EndsWith(")") && !x.StartsWith("/") && !x.Contains('&'))
                .Distinct()
                .OrderBy(x => x);

            foreach (var valueName in valueNames)
            {
                valuesWriter.AddXmlDocSummary($"Gets the name of the <c>{valueName}</c> property value.");
                valuesWriter.AddLine($"public const string {valueName.ToPascalCase()} = \"{valueName}\";");
                valuesWriter.AddLine();
            }

            foreach (var propertyName in references.Where(x => x.Properties is not null).SelectMany(x => x.Properties).Select(x => x.Name).Distinct())
            {
                valuesWriter.AddXmlDocSummary($"Gets values which are valid for the <c>{propertyName}</c> property.");
                valuesWriter.AddLine($"public static {propertyName.ToPascalCase()}Values For{propertyName.ToPascalCase()} = new();");
                valuesWriter.AddLine();
            }

            valuesWriter.CloseClass();
            context.AddSource("CssValues.g.cs", valuesWriter.ToString());

            WritePropertySpecificValueClasses(context, references);
            WritePropertySpecificEntryClasses(context, references);
        }

        private void LogInfo(GeneratorExecutionContext context, string message)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    nameof(CssGenerator),
                    $"Source Generated by {nameof(CssGenerator)}",
                    "Message 1: {0}",
                    "Source Generation",
                    DiagnosticSeverity.Info,
                    true),
                Location.None,
                message);

            context.ReportDiagnostic(diagnostic);
        }

        private IEnumerable<CssReference> LoadResources()
        {
            var results = new List<CssReference>();
            Assembly assembly = Assembly.GetExecutingAssembly(); // Use your assembly or another
            string[] resourceNames = assembly.GetManifestResourceNames();
            foreach (string resourceName in resourceNames)
            {
                using var stream = assembly.GetManifestResourceStream(resourceName);
                using var reader = new StreamReader(stream);
                var serialized = reader.ReadToEnd();
                results.Add(JsonConvert.DeserializeObject<CssReference>(serialized)
                    ?? throw new JsonSerializationException($"Unable to deserialize resource '{resourceName}'."));
            }

            return results;
        }

        private void WritePropertiesNamesClass(GeneratorExecutionContext context, IEnumerable<CssReference> references)
        {
            var propertiesWriter = new ClassWriter();

            propertiesWriter.AddLine("namespace WebIdentifiers.Css;");
            propertiesWriter.AddLine();

            propertiesWriter.AddXmlDocSummary("Provides the names of CSS properties.");
            propertiesWriter.OpenClass("CssPropertyNames", isStatic: true);

            var lastProperty = string.Empty;
            foreach (var property in references.Where(x => x.Properties is not null).SelectMany(x => x.Properties).OrderBy(x => x.Name))
            {
                if (!lastProperty.Equals(property.Name, StringComparison.Ordinal))
                {
                    lastProperty = property.Name;
                    propertiesWriter.AddXmlDocSummary($"Gets the name of the <c>{property.Name}</c> property.");
                    propertiesWriter.AddLine($"public const string {property.Name.ToPascalCase()} = \"{property.Name}\";");
                    propertiesWriter.AddLine();
                }
            }

            propertiesWriter.CloseClass();

            context.AddSource("CssPropertyNames.g.cs", propertiesWriter.ToString());
        }

        private void WriteEntriesClass(GeneratorExecutionContext context, IEnumerable<CssReference> references)
        {
            var entriesWriter = new ClassWriter();

            entriesWriter.AddUsings("WebIdentifiers.Css.Properties");
            entriesWriter.AddLine("namespace WebIdentifiers.Css;");
            entriesWriter.AddLine();

            entriesWriter.AddXmlDocSummary("Provides access to specific CSS property entry objects.");
            entriesWriter.OpenClass("CssProperties", isStatic: true);

            var lastProperty = string.Empty;
            foreach (var property in references.Where(x => x.Properties is not null).SelectMany(x => x.Properties).OrderBy(x => x.Name))
            {
                if (!lastProperty.Equals(property.Name, StringComparison.Ordinal))
                {
                    lastProperty = property.Name;
                    entriesWriter.AddXmlDocSummary($"Gets a new <see cref=\"CssEntity\"> instance initialized with a property name of <c>{property.Name}</c>.");
                    entriesWriter.AddLine($"public static {property.Name.ToPascalCase()}Property {property.Name.ToPascalCase()} => new();");
                    entriesWriter.AddLine();
                }
            }

            entriesWriter.CloseClass();

            context.AddSource("CssProperties.g.cs", entriesWriter.ToString());
        }

        private void WritePropertySpecificEntryClasses(GeneratorExecutionContext context, IEnumerable<CssReference> references)
        {

            var files = new Dictionary<string, int>();
            var propertyGroups = references.Where(x => x.Properties is not null).SelectMany(x => x.Properties).GroupBy(x => x.Name);

            foreach (var property in propertyGroups)
            {
                var values = property.Where(x => x.Values is not null).SelectMany(x => x.Values)
                    ?.Where(x => !x.Name.Contains('<') && !x.Name.Contains('|') && !x.Name.StartsWith("[") && !x.Name.EndsWith(")") && !x.Name.StartsWith("/") && !x.Name.Contains('&'))
                    .OrderBy(x => x.Name)
                    ?? Enumerable.Empty<CssPropertyValue>();

                var writer = new ClassWriter();

                writer.AddLine("namespace WebIdentifiers.Css.Properties;");
                writer.AddLine();

                var propertyName = $"{property.Key.ToPascalCase()}";
                var entryClassName = $"{propertyName}Property";

                writer.AddXmlDocSummary($"Provides a CSS entry for the {propertyName} property.");
                writer.OpenClass(entryClassName, "CssPropertyEntry");

                writer.AddXmlDocSummary($"Represents a {property.Key} CSS property entry.");
                writer.AddLine("/// <param name=\"value\">An optional value with which to initialize the CSS property entry.</param>");
                writer.AddLine($"public {entryClassName}(string? value = null)");
                writer.AddChildLine($": base(CssPropertyNames.{propertyName}, value)");
                writer.OpenBlock();
                writer.CloseBlock();

                if (values.Any())
                {
                    var lastValue = string.Empty;
                    foreach (var value in values)
                    {
                        if (!lastValue.Equals(value.Name, StringComparison.OrdinalIgnoreCase))
                        {
                            lastValue = value.Name;
                            writer.AddXmlDocSummary($"Sets the value of the property entry to <c>{value.Name}</c>. {value.Prose}");
                            writer.AddLine($"public {entryClassName} SetTo{value.Name.ToPascalCase()}()");
                            writer.OpenBlock();
                            writer.AddLine($"Value = CssValues.{value.Name.ToPascalCase()};");
                            writer.AddLine("return this;");
                            writer.CloseBlock();
                            writer.AddLine();
                        }

                    }
                }

                writer.CloseClass();

                var fileSuffix = string.Empty;
                var coreFileName = property.Key.ToPascalCase().Trim();
                var fileKey = coreFileName.ToUpper();
                if (files.ContainsKey(fileKey))
                {
                    files[fileKey] = files[fileKey] + 1;
                }
                else
                {
                    files[fileKey] = 1;
                }

                if (files[fileKey] > 1)
                {
                    fileSuffix = files[fileKey].ToString();
                }

                try
                {
                    var fileName = $"Properties/{coreFileName}Property{fileSuffix}.g.cs";
                    context.AddSource(fileName, writer.ToString());
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex);
                    throw;
                }

            }
        }


        private void WritePropertySpecificValueClasses(GeneratorExecutionContext context, IEnumerable<CssReference> references)
        {

            var files = new Dictionary<string, int>();
            var propertyGroups = references.Where(x => x.Properties is not null).SelectMany(x => x.Properties).GroupBy(x => x.Name);

            foreach (var property in propertyGroups)
            {
                var values = property.Where(x => x.Values is not null).SelectMany(x => x.Values)
                    ?.Where(x => !x.Name.Contains('<') && !x.Name.Contains('|') && !x.Name.StartsWith("[") && !x.Name.EndsWith(")") && !x.Name.StartsWith("/") && !x.Name.Contains('&'))
                    .OrderBy(x => x.Name)
                    ?? Enumerable.Empty<CssPropertyValue>();

                var writer = new ClassWriter();

                writer.AddLine("namespace WebIdentifiers.Css.Values;");
                writer.AddLine();


                writer.OpenClass($"{property.Key.ToPascalCase()}Values", "PropertyValuesBase");

                if (values.Any())
                {
                    var lastValue = string.Empty;
                    foreach (var value in values)
                    {
                        if (!lastValue.Equals(value.Name, StringComparison.OrdinalIgnoreCase))
                        {
                            lastValue = value.Name;
                            writer.AddXmlDocSummary($"Gets the name of the <c>{value.Name}</c> property. {value.Prose}");
                            writer.AddLine($"public string {value.Name.ToPascalCase()} => CssValues.{value.Name.ToPascalCase()};");
                            writer.AddLine();
                        }

                    }
                }

                writer.CloseClass();

                var fileSuffix = string.Empty;
                var coreFileName = property.Key.ToPascalCase().Trim();
                var fileKey = coreFileName.ToUpper();
                if (files.ContainsKey(fileKey))
                {
                    files[fileKey] = files[fileKey] + 1;
                }
                else
                {
                    files[fileKey] = 1;
                }

                if (files[fileKey] > 1)
                {
                    fileSuffix = files[fileKey].ToString();
                }

                try
                {
                    var fileName = $"Values/{coreFileName}Values{fileSuffix}.g.cs";
                    context.AddSource(fileName, writer.ToString());
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex);
                    throw;
                }

            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // required by ISourceGenerator
        }
    }
}
